<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Éditeur de Niveau pour Bobby</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      display: flex;
      flex-direction: row;
      margin: 0;
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    #canvas-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #87CEEB;
      padding: 10px;
    }
    #canvas {
      border: 1px solid #000;
      cursor: crosshair;
      max-width: 100%;
      max-height: 100%;
    }
    #controls {
      width: 250px;
      display: flex;
      flex-direction: column;
      padding: 20px;
      background-color: #f4f4f4;
      box-shadow: -3px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto;
    }
    .button {
      margin: 5px 0;
      padding: 10px;
      font-size: 14px;
      cursor: pointer;
      background-color: #007BFF;
      color: #fff;
      border: none;
      border-radius: 5px;
      text-align: center;
    }
    .button:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="canvas" width="900" height="540"></canvas>
  </div>
  <div id="controls">
    <button class="button" onclick="setMode('player')">Ajouter Joueur</button>
    <button class="button" onclick="setMode('target')">Ajouter Objectif</button>
    <button class="button" onclick="setMode('hill')">Ajouter Colline</button>
    <button class="button" onclick="setMode('hillFront')">Ajouter Colline Avant</button>
    <button class="button" onclick="setMode('cloud')">Ajouter Nuage</button>
    <button class="button" onclick="setMode('platform')">Ajouter Plateforme</button>
    <button class="button" onclick="setMode('enemy')">Ajouter Ennemi</button>
    <button class="button" onclick="setMode('spike')">Ajouter Pique</button>
    <button class="button" onclick="setMode('fallingBlock')">Ajouter Bloc Tombant</button>
    <button class="button" onclick="setMode('oneWayPlatform')">Ajouter Plateforme Unidirectionnelle</button>
    <button class="button" onclick="exportLevel()">Exporter Niveau</button>
    <button class="button" onclick="setMode('remove')">Mode Suppression</button>
    <button class="button" onclick="setMode('move')">Mode Déplacement</button>
    <button class="button" onclick="moveCamera('left')">Caméra Gauche</button>
    <button class="button" onclick="moveCamera('right')">Caméra Droite</button>
    <button class="button" onclick="moveCamera('up')">Caméra Haut</button>
    <button class="button" onclick="moveCamera('down')">Caméra Bas</button>
  </div>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 40;
    let levelsData = {
      level1: { player: null, target: null, hills: [], hillsFront: [], clouds: [], platforms: [], enemies: [], spikes: [], fallingBlocks: [], oneWayPlatforms: [] }
    };
    let currentMode = null;
    let selectedElement = null;
    let cameraOffsetX = 0;
    let cameraOffsetY = 0;

    function setMode(mode) {
      currentMode = mode;
      selectedElement = null;
    }

    function addElement(x, y) {
      x = Math.round(x / gridSize) * gridSize; //+ cameraOffsetX;
      y = Math.round(y / gridSize) * gridSize; //+ cameraOffsetY;
      const element = { x, y };

      switch(currentMode) {
        case 'player': levelsData.level1.player = element; break;
        case 'target': levelsData.level1.target = element; break;
        case 'hill': levelsData.level1.hills.push(element); break;
        case 'hillFront': levelsData.level1.hillsFront.push(element); break;
        case 'cloud': levelsData.level1.clouds.push(element); break;
        case 'platform': 
          levelsData.level1.platforms.push({ x, y, width: gridSize, height: gridSize });
          break;
        case 'enemy': levelsData.level1.enemies.push(element); break;
        case 'spike': levelsData.level1.spikes.push(element); break;
        case 'fallingBlock': levelsData.level1.fallingBlocks.push(element); break;
        case 'oneWayPlatform': 
          levelsData.level1.oneWayPlatforms.push({ x, y, width: gridSize });
          break;
      }
      redrawLevel();
    }

    function exportLevel() {
      const exportedData = JSON.stringify(levelsData.level1, null, 2);
      navigator.clipboard.writeText(exportedData).then(() => alert("Niveau copié dans le presse-papiers !"));
    }

    function drawGrid() {
      ctx.strokeStyle = "#CCCCCC";
      for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    function redrawLevel() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();

      const offsetDraw = (x, y) => ({ x: x - cameraOffsetX, y: y - cameraOffsetY });

      if (levelsData.level1.player) {
        const { x, y } = offsetDraw(levelsData.level1.player.x, levelsData.level1.player.y);
        drawPlayer(x, y);
      }
      if (levelsData.level1.target) {
        const { x, y } = offsetDraw(levelsData.level1.target.x, levelsData.level1.target.y);
        drawTarget(x, y);
      }
      levelsData.level1.hills.forEach(hill => {
        const { x, y } = offsetDraw(hill.x, hill.y);
        drawHill(x, y);
      });
      levelsData.level1.hillsFront.forEach(hillFront => {
        const { x, y } = offsetDraw(hillFront.x, hillFront.y);
        drawHillFront(x, y);
      });
      levelsData.level1.clouds.forEach(cloud => {
        const { x, y } = offsetDraw(cloud.x, cloud.y);
        drawCloud(x, y);
      });
      levelsData.level1.platforms.forEach(platform => {
        const { x, y } = offsetDraw(platform.x, platform.y);
        drawPlatform(x, y, platform.width, platform.height);
      });
      levelsData.level1.enemies.forEach(enemy => {
        const { x, y } = offsetDraw(enemy.x, enemy.y);
        drawEnemy(x, y);
      });
      levelsData.level1.spikes.forEach(spike => {
        const { x, y } = offsetDraw(spike.x, spike.y);
        drawSpike(x, y);
      });
      levelsData.level1.fallingBlocks.forEach(block => {
        const { x, y } = offsetDraw(block.x, block.y);
        drawFallingBlock(x, y);
      });
      levelsData.level1.oneWayPlatforms.forEach(platform => {
        const { x, y } = offsetDraw(platform.x, platform.y);
        drawOneWayPlatform(x, y, platform.width);
      });
    }

    function drawPlayer(x, y) { ctx.fillStyle = "white"; ctx.fillRect(x, y, gridSize, gridSize); }
    function drawTarget(x, y) { ctx.fillStyle = "red"; ctx.fillRect(x, y, gridSize, gridSize); }
    function drawHill(x, y) { ctx.fillStyle = "green"; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + gridSize, y); ctx.lineTo(x + gridSize / 2, y - gridSize); ctx.fill(); }
    function drawHillFront(x, y) { ctx.fillStyle = "gray"; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + gridSize, y); ctx.lineTo(x + gridSize / 2, y - gridSize); ctx.fill(); }
    function drawCloud(x, y) { ctx.fillStyle = "lightblue"; ctx.beginPath(); ctx.arc(x + gridSize / 2, y + gridSize / 2, gridSize / 2, 0, Math.PI * 2); ctx.fill(); }
    function drawPlatform(x, y, width, height) { ctx.fillStyle = "brown"; ctx.fillRect(x, y, width, height); }
    function drawEnemy(x,y) { ctx.fillStyle = "purple"; ctx.fillRect(x, y, gridSize, gridSize); }
    function drawSpike(x, y) { ctx.fillStyle = "black"; ctx.beginPath(); ctx.moveTo(x, y + gridSize); ctx.lineTo(x + gridSize / 2, y); ctx.lineTo(x + gridSize, y + gridSize); ctx.fill(); }
    function drawFallingBlock(x, y) { ctx.fillStyle = "darkgray"; ctx.fillRect(x, y, gridSize, gridSize); }
    function drawOneWayPlatform(x, y, width) { ctx.fillStyle = "lightgray"; ctx.fillRect(x, y, width, gridSize / 4); }

    function moveCamera(direction) {
      const moveAmount = gridSize;
      switch (direction) {
        case 'left': cameraOffsetX -= moveAmount; break;
        case 'right': cameraOffsetX += moveAmount; break;
        case 'up': cameraOffsetY -= moveAmount; break;
        case 'down': cameraOffsetY += moveAmount; break;
      }
      redrawLevel();
    }

    canvas.addEventListener('click', event => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left + cameraOffsetX;
      const y = event.clientY - rect.top + cameraOffsetY;

      if (currentMode === 'remove') {
        removeElement(x, y);
      } else if (currentMode === 'move') {
        selectElement(x, y);
      } else {
        addElement(x, y);
      }
    });

    function selectElement(x, y) {
      selectedElement = findElement(x, y);
      if (selectedElement) {
        document.body.addEventListener('keydown', handleMove);
      }
    }

    function handleMove(event) {
      if (!selectedElement) return;
      const moveAmount = gridSize;
      switch (event.key) {
        case 'ArrowLeft': selectedElement.x -= moveAmount; break;
        case 'ArrowRight': selectedElement.x += moveAmount; break;
        case 'ArrowUp': selectedElement.y -= moveAmount; break;
        case 'ArrowDown': selectedElement.y += moveAmount; break;
      }
      redrawLevel();
    }

    function findElement(x, y) {
      return levelsData.level1.hills.concat(levelsData.level1.hillsFront, levelsData.level1.clouds, levelsData.level1.platforms, levelsData.level1.enemies, levelsData.level1.spikes, levelsData.level1.fallingBlocks, levelsData.level1.oneWayPlatforms)
        .find(elem => Math.abs(elem.x - x) < gridSize && Math.abs(elem.y - y) < gridSize);
    }

    function removeElement(x, y) {
      ['hills', 'hillsFront', 'clouds', 'platforms', 'enemies', 'spikes', 'fallingBlocks', 'oneWayPlatforms'].forEach(group => {
        levelsData.level1[group] = levelsData.level1[group].filter(elem => !(Math.abs(elem.x - x) < gridSize && Math.abs(elem.y - y) < gridSize));
      });
      redrawLevel();
    }
    window.onload = () => { redrawLevel(); };
</script>
</body>
</html>
